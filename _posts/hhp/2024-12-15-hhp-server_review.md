---
layout: single
title: "[항해+] Concert 서버 구축 개발 회고"
categories: 
 - Hhp
date: 2024-12-15 11:45:30:00 +0900
---
## 1. 과제의 핵심

- 통합테스트 작성
- 동시성 이슈 테스트
- 대기열 시스템 구현

## 2. 이번 주 나의 고민

- [테스트] 핵심 기능 위주로 구현 마무리 및 적당한 통합 테스트 작성
- [동시성] 동시성 상황을 찾고 트랜젝션 격리레벨을 고민해보자
- [아키텍처] 도메인 레이어의 컴포넌트 역할 재정의
- [구현문제] 대기열 시스템 구현

## 3. 고민을 좀 더 상세하게

**1) [테스트] 테스트 케이스 작성에 대한 나의 고찰**

성공케이스를 먼저 고려하여 테스트 케이스를 작성하였고 이어서 실패 케이스도 작성하였다. 이유는 실패에 대한 예외 상황은 결국 성공케이스의 반례를 찾는 과정이기 때문에 성공케이스를 먼저 작성하는게 맞다고 생각한다.

그렇기에 생각의 순서에도 맞고 테스트케이스 정리에도 도움 되기 때문이다. 그리고 대체적으로 성공 케이스의 수는 고정적이지만(거의 한가지) 실패케이스는 유동적이기에 더욱 그렇다.

**2) [테스트] 핵심 기능 위주로 구현 마무리 및 적당한 통합 테스트 작성**

콘서트 예약에 가장 핵심적인 기능인 예약과, 결제, 그리고 대기열 테스트 위주로 테스트케이스를 잡았으며, 시간관계상 실패케이스는 한정적으로 잡았다. 

예약에 대한 케이스는 간단하게는 아래와 같은 상황이 있다.

- 예약 케이스에 대한 시나리오
    - 정상 예약 시나리오
    - 이미 예약한 좌석을 예약한 경우
    - 두 명 이상이 동시에 같은 좌석에 대한 예약 진행
- 결제 케이스 대한 시나리오
- 돈 충전 시나리오

**3) [동시성] 동시성 문제가 발생할 수 있는 케이스를 먼저 찾자!**

여러 사용자가 동시에 접속하여 성능 혹은 데이터정합성에 대해 문제가 발생할 수 있는 상황은 “공유 데이터를 수정”했을 때 뿐이라고 생각한다.  사용자가 쓰기 작업을 진행하는 상황을 아래와 같다.

- 좌석정보 수정 —> 유일한 사용자간 공유영역!
    - 예약 ID 컬럼을 갱신하여 예약 여부를 파악
- 예약내역 추가 —> 사용자간 공유영역 아님! 게다가 수정도 불가!
- 결제내역 추가 —> 사용자간 공유영역 아님! 게다가 수정도 불가!
- 돈 충전  —> 사용자간 공유영역 아님!
- 돈 사용 —> 사용자간 공유영역 아님!

그 외 수정가능한 상황

- 대기열 상태 갱신  —> 시스템 스케쥴러가 처리
- 콘서트 입력, 수정, 삭제  —> 관리자가 처리
- 스케쥴 입력, 수정, 삭제 —> 관리자가 처리

공연정보와 스케쥴정보 그리고 좌석정보는 관리자가 입력 수정해주는 사항이라고 가정한다면 예약하는 사용자가 겪을 수 있는 예외상황은 좌석을 예매하였을 때 뿐이다. 

만약 동시에 여러명이 같은 공연, 같은 시간, 같은좌석을 예매하려 한다면 가장 먼저 예매한 자만이 예매가 가능하게 하고 나머지 사람들은 전부 Exception을 주어 실패로 처리하게끔 한다. 100명이 동시에 같은 좌석을 예매시도 한다면 1명만 예매 나머지 99명은 실패!

성공한 사용자에 대한 예약정보가 추가되고 좌석은 Occupy 상태가 된다.

**4) [동]시성 다그면다 격리레벨은? 락은 비관적락? 낙관적락?**

예매 라는 하나의 트랜젝션 처리시 발생할 수 있는 DB 접근을 고려해본다면 아래와 같이 생각할 수 있다.

1. 좌석이 예약 되었는지 확인하기 위해 접근(Seats 조회)
2. 예약도메인 객체를 생성하고, 예약 정보 추가하기 위해 접근 (Reservation insert)
3. 좌석도메인에 생성한 Reservation의 id를 추가하여 수정한다.(Seat update)

- **격리수준에 대한 고민**

**Read Committed이면 충분하다.**

**Repeatable Read는 필요없다!**

예약 처리시 만약 같은 조건의 데이터를 조회하는 상황 그 데이터는 일관성이 있을 필요가 없다!

왜냐면 테이블의 상태를 검사하는 목적이 때문에 오히려 커밋되는 데이터를 잘 반영할 수록 목적에 맞게 정합성이 높아진다. MySql은 기본 격리수준이 Repeatable Read이므로 오히려 수준을 Read Committed로 낮춰주는 것이 성능상 이점을 가져갈 수 있다고 생각한다.

- **락에 대한 고민**

**낙관적 Lock이면 충분하지 싶다.**

내가 조회하고 쓰기를 수행하는 도중에 누군가가 이미 쓰기를 시도하거나 이미 쓰여진 경우에 예외로 처리되어 트랜젝션을 중단하게끔 하기만 한다면 동시예약 문제는 해결될 수 있을 것으로 본다. 만약 베타락을 걸게 된다면 좌석에 대해 조회 베타락을 걸어야 될 수도 있는데 동시 처리 인원이 많을 수록 성능 낭비가 심할 것으로 보인다.

**5) [아키텍처] 도메인의 컴포넌트 의존방향과 책임분리**

아래와 같은 구조로 설계하였다. 

```jsx
컨트롤러 → 유스케이스 → [ 도메인 → 레파지토리인터페이스 ](도메인영역) ← 인프라
```

구조상 의도한 의존 방향은 컴포넌트간의 상호 의존성을 존재하지 않는다. 

혹시나 같은 도메인 안에서 컨포넌트간 의존 관계가 존재한다면 그 안에서도 계층을 나누어 순환참조를 방지하자! 

였다.

또 하나는 UseCase Layer에는 구현 로직을 삼가할 것!

구현로직은 컴포넌트에게 맡기자!
![image-right](/assets/images/post/2024-12-15-hhp-server_review/diagram.png){: .align-center}
모든 로직은 ReserveUseCase까지 끌고 와서 처리하도록!

저러면 고민이 하나 생기는데 

ReverveUseCase에서 컴포넌트극 가지고 로직 흐름제어(if문 for문을 사용하여)와 같은 로직구현의 여지가 생길 수 있다. 예를 들어 SeatReader로 좌석정보를 가져와서 검사한다면 좌석이 있다면 예외 아니면 다음 컴포넌트의 기능 수행 등의 흐름등이 생길 여지가 있는데 이 마저도 컴포넌트에게 역할을 위임하기 위해 SeatValidator를 만들었다. 

**6) [대기열 구현] 대기열 고민**

대기열 상태 체크 및 갱신방법은?

1. 클라이언트 폴링 (클라이언트 working)
2. 스케쥴러에 (서버 workgin)
3. SSE(Server Sent Event) (서버 working)

처음에는 클라이언트 폴링에 대해 부적적인 생각을 하였다. 이유는 네트워크 홉에 대한 비용이 상당할 것이라고 생각했기 때문이다. 만약 사용자가 100만명이라면 그 네트워크 트래픽이 어마어마할 것이라고 생각했다.

그래서 서버 스케쥴링 주기를 짧게 갖고 서버에서만 처리하게끔 하려고 했는데 접속 주체인 클라이언트가 “나 지금 접속중이오 나 아직 안나갔소!” 아니면 “난 이제 그만 물러가겠소!”등의 의사표현을 주기적으로 날려줘야 대기열의 상태를 실시간으로 갱신할 수 있다고 판단하였다.

클라이언트 폴링만 존재한다면 문제는 클라리언트 의존적으로 서버 대기열 상태를 체크 하고 갱신하기 때문에 사용자간 순서 간극으로 인하여 정합성이 떨어질 것으로 판단하였다.

결론적으로는 클라이언트 폴링과 서버 스케쥴러 둘 다 사용하되 역할을 다르게 하는 것이다.

클라이언트 폴링은 단순히 “이보시오 나 아직 살아있소!” 체크만

서버 스케쥴러는 대기열을 대기시간으로 판단하여 상태 갱신!

그렇다면 실시간성과 정합성 둘 다 문제없이 챙길 수 있다고 생각한다.

SSE를 적용하려 했지만 결국 이는 클라이언트별로 웹소켓처럼 연결을 성립시켜줘야 하기 때문에 이에 따른 자원 소모가 존재한다.(100만 명이면 연결이 성립되는 동안 100만명분의 메모리를 잡아먹는다.)

**결론** 

폴링(나 살아있소, 지금 나 들어가도 되오?체크) + 스케쥴러(상태변경)