---
layout: single
title: "[MY SQL] 트랜잭션과 격리레벨"
categories: 
 - Mysql
date: 2024-12-16 10:03:00 +0900
toc: true
toc_sticky: true
---
## 1. 들어가기

데이터베이스를 다룬다면 자연스럽게 트랜젝션이라는 개념을 접하게 된다. RDBMS를 통한 논리적인 로직을 구현하게 된다면,  이 로직은 항상 일관성있는 결과가 도출되기를 기대할 것이다. 이 논리적인 그룹안에 데이터를 다루는 단위가 2개 이상의 쿼리로 구성되어 있게 된다면, 일관성을 보장받기 위한 장치의 필요성을 알게 될 것이다. 

이렇듯 논리적인 그룹셋의 수행 결과가 완전하게 수행되거나 완전하게 회수될 수 있는 장치가 필요하게 되는데 이 때 이 그룹셋을 ‘트랜잭션’이라는 단위로 묶이게 된다.

즉 트랜잭션의 시작과 끝이 존재하고, 트랜잭션이 끝날때, 시작부터 수행했던 모든 쿼리들이 커밋된다.

이 때 두개 이상의 트랜잭션이 동일 자원에 동시에 접근하여 쓰기작업을 하게 되었을 때, 데이터를 공유하기 위한 방법을 특정 수준으로 나누게 되었는데 이를 ‘격리레벨’이라고 한다.

데이터를 공유하는 수준에 따라 발생할 수 있는 문제를 기준으로 격리레벨을 알아보도록 하자.

## 2. 격리레벨

### [Uncommited Read] → DirtyRead!

Dirty Read는 말 그대로 지저분한 읽기 이다.

격리수준이 Uncommited Read일때 발생하는 문제이다.

데이터가 커밋되지 않아도 트랜젝션간 데이터를 공유할 수 있어, 의도치 않게 잘못된 데이터를 읽을 수 있게 되는 문제이다. 

아래 그림을 보자

그림

A라는 트랜잭션이 먼저 실행되고 A가 Col1의 데이터를 “ING”라고 쓰고 나서 B라는 트랜잭션이 시작되면서 해당 데이터를 읽었다. 이 후 A는 Col1의 데이터를 “DONE”이라고 썼다. B라는 트랜잭션은 원래 “DONE”이라는 데이터를 읽어야 했지만 A라는 데이터가 트랜잭션 처리 과정중 잠시 변경작업을 한 “ING”라는 데이터를 읽게 되어 데이터의 정합성에 문제가 발생하게 되었다.

위와 같은 상황을 극복하기 위해서는 서로 다른 트랜잭션사이에는 커밋된 데이터만 공유할 수 있도록 Commited Read로 격리레벨을 격상한다.

### [Commited Read] → Non Repeatable Read

Commited Read 레벨로 변경하면서 Dirty Read의 문제는 해결하게 되었다. 하지만 아래와 같은 문제가 또한 발생하였다. 

A트랜잭션이 “주문” 테이블에 “재고량” 데이터를 읽었다. 값은 30이다. 

B라는 트랜잭션이 동일한 테이블에 재고량 데이터를 읽고 5개를 소진한 재고량을 업데이트하고 트랜잭션을 끝내버렸다. (커밋되었다.) 재고량 데이터는 25가 되었다.

A트랜잭션은 아직 끝나지 않은 상황에서 또 다시 재고량 데이터를 조회하였다. 하지만 트랜잭션이 아직 끝나기 전이기 때문에 이전과 동일한 30이라는 데이터를 조회하기 기대했지만 25를 조회하였다 

동일한 데이터를 반복조회하였을때 기대한 동일한 값을 조회하지 못하였다. 위와같은 현상을 “Non Repeatable Read”라고 한다.

그림

위 상황을 극복하기 위해 Read 데이터를 세션별로 할당된 “언두(Undo)영역”에 두고 같은 트랜잭션 내에서는 해당 영역에서 데이터를 조회하여 처리하도록 한다. 이와 같은 방식은 MVCC를 통해 가능하게 한다.

MVCC(Multi-Version Concurrency Control)는 트랜잭션이 시작된 시점의 데이터 스냅샷을 유지하여, 트랜잭션 내에서 일관된 데이터를 읽을 수 있도록 한다. 이를 구현하는 방식 중 하나로 ‘Undo 영역’을 활용하여 이전 데이터를 보관할 수 있으며, 데이터베이스 시스템마다 구현 방식에 차이가 있다.

### [Repeatable Read] → Phantom Read

MVCC를 이용하여 같은 트랜잭션내에서는 해당 트랜잭션이 시작된 이 후 Commit되기 이전 데이터를 읽게 할 수 있게 하여 Non Repeatable Read문제를 극복하였다. 

하지만 위와 같은 상황에서는 다음과 같은 문제가 있었다.

```sql
SELECT 재고 FROM 주문 재고 ≥ 30 
```

만약 위와같이 A 트랜잭션이 쿼리를 조회하였다고 가정해보자. SELECT FOR UPDATE로 조회하였을 때 돌아오는 결과같은 1000이다. 하지만 A트랜잭션이 끝나기 전에 B트랜잭션이 재고 50의 데이터를 INSERT하게된다면 

A가 조회한 데이터를 1001이 되게 된다. A는 특정 레코드에 대해 “언두영역”을 할당받아 Repeatable Read가 가능하게 되었지만 LOCKING한 레코드가 아닌 새로운 레코드가 추가되었을 때 없던 데이터가 생기게 되었다. 

이렇게 데이터가 숨어있다가 나오고, 나오다가 숨고하는 현상을 Phantom Read라고 한다. 위와 같은 상황을 방지하기 위해서는 가장 강력한 격리 레벨이 있다.

Phantom Read는 새로운 레코드가 추가되거나 삭제될 때 발생하며, 일부 데이터베이스(MySQL 등)에서는 Repeatable Read 격리 수준에서도 MVCC를 통해 Phantom Read를 방지할 수 있다. 그러나 Serializable 수준을 사용하면 완전히 차단할 수 있다.

### [Serialization]

충동 되는 두 트랜잭샌이 존재할 시 먼저 선점한 트랜잭션이 종료할 때 까지 다른 트랜잭션은 대기하는 것이다. 즉 동시에 접근하여도 무조건 순차적으로 처리하게 하는 방식이다. 해당 방법은 확실하게 동시 접근으로 인한 데이터 정합성에 대한 문제는 깔끔하게 해결하여 주지만, 무조건 순차처리를 해야된다는 측면에서 그 트래픽이 많아지게 되면, 전체적인 성능은 떨어질 수 있다는 단점이 있다. 

즉 안정성은 우수하지만, 속도는 떨어진다. 

## 3. 정리

### 격리수준별 졍리
아래 표는 위 4가지 격리레벨을 동시접근으로 인한 문제와 함께 정리한 자료이다.


![image-right](/assets/images/post/2024-12-16-mysql-isolation-level/table_iso.png){: .align-center}

### RDBMS별 기본 격리레벨
기본적으로 제공하는 격리레벨은 DB마다 다르다. Mysql 같은 경우에는 “Repeatable Read”가 기본 격리 레벨이고, Oracle과 Postgress는 Read Committed가 기본 격리레벨이다. 아래 표는 RDBMS별 기본 격리레벨을 정리한 것이다.

| RDBMS       | 격리수준           | 설명                                          | 방지                  |
|-------------|-------------------|---------------------------------------------|----------------------|
| Postgres    | READ COMMITTED    | 커밋된 데이터만 읽을 수 있음                  | Dirty Read 방지       |
| MySQL       | REPEATABLE READ   | 동일 트랜잭션 내 동일 쿼리 결과를 보장         | Phantom Read 방지 안됨 |
| Oracle      | READ COMMITTED    | 커밋된 데이터만 읽을 수 있음                  | Dirty Read 방지       |
| SQL Server  | READ COMMITTED    | 커밋된 데이터만 읽을 수 있음                  | Dirty Read 방지       |
| SQLite      | SERIALIZABLE      | 가장 엄격한 수준. 트랜잭션 간 충돌을 방지       | 엄격                  |